#from somTools
#Copyright 2012 David H. Brown
#GPL license available
##' subdivide line segments given as points in rows of a matrix, each
##' connected to the next.
##' 
##' if byrow=TRUE, matrix is considered to be start points in first
##' half of columns and endpoints in second half of columns; e.g., 
##' as generated by somTools.node.edges(). Rows do not
##' necessarily connect. 
##'
##' Tested with two dimensions, but ought to work with more
subdivide <- function(coord.matrix, newpoints=1, byrow=FALSE) {
  if(is.list(coord.matrix)) {
    for(i in 1:length(coord.matrix)) {
      if(is.matrix(coord.matrix[[i]])) {
        coord.matrix[[i]]<-subdivide(coord.matrix[[i]],newpoints=newpoints,byrow=byrow)
        }#if
      }#for
      return(coord.matrix)
    }#if
  if(byrow) {
    if(ncol(coord.matrix)%%2>0) {
      stop('Number of columns must be even for subdivide to work byrow')
      }
    new.matrix <- matrix(0,
       nrow(coord.matrix)*(newpoints+1),
       ncol=ncol(coord.matrix),
       dimnames=dimnames(coord.matrix)
      )
    dims <- ncol(coord.matrix)/2 #probably = 2
    for(i in 1:nrow(coord.matrix)) {
      row.in.new.matrix <- (i-1)*(newpoints+1)+1
      tmp <- subdivide(matrix(c(coord.matrix[i,]),ncol=dims,byrow=TRUE),newpoints=newpoints)
      #tmp should have row for start, row for end, and newpoints rows for new points
      #if(nrow(tmp)!=newpoints+2) warn(paste("nrow(tmp)=",nrow(tmp),", but newpoints+2=",newpoints+2))
      #the above check seems unnecessary; we're correct so far
      for(j in 1:dims) {
        new.matrix[row.in.new.matrix:(row.in.new.matrix+newpoints),j] <- tmp[1:(newpoints+1),j]
        new.matrix[row.in.new.matrix:(row.in.new.matrix+newpoints),j+dims] <- tmp[2:(newpoints+2),j]
        } #for dimensions == columns in tmp
      } #for rows in coord.matrix
    return(new.matrix)
  }#if byrow
  new.matrix <- matrix(0,
    nrow=(nrow(coord.matrix)-1)*(newpoints)+nrow(coord.matrix),
    ncol=ncol(coord.matrix),
    dimnames=dimnames(coord.matrix)
    )
  for(i in 2:nrow(coord.matrix)) {
    segment=(coord.matrix[i,]-coord.matrix[i-1,])/(newpoints+1)
    for(j in 0:newpoints) {
      new.matrix[(i-2)*(newpoints+1)+j+1,] <- coord.matrix[i-1,]+j*segment
      #averaging from top and bottom didn't help ((coord.matrix[i-1,]+j*segment)+(coord.matrix[i,]-(newpoints-j)*segment))/2
      }
    }
  new.matrix[nrow(new.matrix),]=coord.matrix[nrow(coord.matrix),]
  new.matrix
}
